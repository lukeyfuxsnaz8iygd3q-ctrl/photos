# TodoTracker Client Implementation Documentation

## Project Overview

This is a TCP socket-based TodoTracker client program designed to communicate with a server for managing todo list tasks.

## Implementation Steps Detailed
### Task 1: Socket Initialization
```python
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
except socket.error as e:
    print(f"Failed to create socket: {e}")
    sys.exit(1)
```
**Implementation Details:**

-   Uses `socket.socket()` function to create TCP socket
    
-   Includes exception handling to ensure graceful program exit if socket creation fails

### Task 2: Connection Request Initiation

**Implementation Code:**
```python
try:
        s.connect((server_ip, server_port))
        print(f"Connected to TodoTrackerServer at {server_ip}:{server_port}")
except Exception as e:
        print(f"Error connecting to server at {server_ip}:{server_port}: {e}")
        sys.exit(1)
```
**Implementation Details:**
    
-   Uses `s.connect()` to establish TCP connection with server
    
-   Includes exception handling for connection failures
### Task 3,4,5: Send commands to server, Receive message from the server and Close socket
| Aspect                | `send()`/`recv()`                  | `makefile().write()`/`read()`      |
|-----------------------|-------------------------------------|-------------------------------------|
| **Data Format**       | Raw bytes                           | Strings (auto-encoding)            |
| **Buffering**         | No buffering                        | Buffered                           |
| **Ease of Use**       | Manual handling required            | File-like operations, simpler      |
| **Control Level**     | Fine-grained control                | High-level abstraction             |
| **Performance**       | More efficient, no overhead         | Has buffering overhead             |
| **Line Processing**   | Manual implementation required      | Built-in `readline()` support      |

So I wrote both two types method to reach the requirement.
**Processing Logic:**
 -   Add, Remove, Mark don't need the server to output the detail of the information just OK.
So we combine Add, Remove, and Mark together.
 -   List and Quit hold their own codes.

**Implementation Code ( send and recieve ) :**

```python
    
try:
        while True:
            # 1. Get command from user
            command_line = input("client :")

            # 2. Send the command to the server
            s.send((command_line + '\n').encode('utf-8'))
            command_base = command_line.split()[0].upper()

            # 3. Handle commands that require multi-line input
            if command_base in ['ADD', 'REMOVE', 'MARK']:
                # Read multi-line input from the user and send to server
                user_input_line=""
                while True:
                    Input=input("client :")
                    user_input_line = user_input_line+Input+"\n"# No prompt for multi-line part
                    
                    if Input == '#':
                        break
                s.send((user_input_line).encode('utf-8'))
            # 4. Receive and process the server's response
            if command_base == 'LIST':
                # Read multi-line response from the server
 
                while True:
                    line = read_line(s)
                    if line == '#':
                        break
                    print(line)
            
            elif command_base == 'QUIT':
                # Read the final 'OK' and then exit
                response = s.recv(1024).decode('utf-8')
                print(f"server: {response}")
                break # Exit the main 'while True' loop
            
            else:
                response = s.recv(1024).decode('utf-8')
                print(f"server: {response}")

    except EOFError:
        print("\nClient shutting down (EOF detected).")
    except Exception as e:
        print(f"An error occurred: {e}")
    finally:
        s.close()
```
**Implementation Details:**
 
1.  ADD 
    
    -   Sends "ADD\n" to server. 
        
    -   Stops reading when user inputs standalone "#" and sends all content
    - Receives "OK\n" or error message. And prints server response
2.  LIST 
    
    -   Sends "LIST\n" to server
        
    - Uses `read_line()` function to read line by line
    - Continuously reads until encountering standalone "#" line
    - Prints all received task information
  
        
3.  REMOVE 
    
    -   Sends "REMOVE\n" to server
        
    -   Continuously reads task IDs, appending "\n" after each line
        
    -   Stops reading when user inputs standalone "#" and sends all IDs
    - Receives "OK\n" or "ERROR - Invalid ID\n". And prints server response
        
4.  MARK 
    
    -   Sends "MARK\n" to server
        
    -   Continuously reads task IDs, appending "\n" after each line
        
    -   Stops reading when user inputs standalone "#" and sends all IDs
    - Receives "OK\n" or "ERROR - Invalid ID\n". And prints server response
        
5.  QUIT
     
    -   Sends "QUIT\n" to server
        
    -   Receives "OK\n"
    - Prints "OK" and exits program

**The details and the logic are same. There just some difference exists in codes.**
**Implementation Code ( makefile( ).read( )/write( ) ):**
```python
 try:
        # Using makefile for easier line-by-line reading and writing
        # 'w' for writing, 'r' for reading. buffering=1 means line buffered.
        writer = s.makefile('w', encoding='utf-8', newline='\n')
        reader = s.makefile('r', encoding='utf-8', newline='\n')

        while True:
            # 1. Get command from user
            command_line = input("Client: ")
            if not command_line: # If the user just presses Enter, the string is empty.
                continue # Skip the rest of the loop and ask for input again.

            # 2. Send the command to the server
            writer.write(command_line + '\n') # .write() adds the string to an internal buffer.
            writer.flush() # Ensure the command is sent immediately

            command_base = command_line.split()[0].upper()

            # 3. Handle commands that require multi-line input
            if command_base in ['ADD', 'REMOVE', 'MARK']:
                # Read multi-line input from the user and send to server
                while True:
                    user_input_line = input("Client:") #print "Client" ahead each line of input
                    writer.write(user_input_line + '\n')
                    writer.flush()
                    
                    if user_input_line == '#': # The '#' symbol signifies the end of multi-line input.
                        break
            
            # 4. Receive and process the server's response
            if command_base == 'LIST':
                # Read multi-line response from the server
                print("\n--- Task List ---")
                while True:
                    response_line = reader.readline().strip() # .strip() removes any leading/trailing whitespace
                    if response_line == '#':
                        break
                    print(response_line)# Print the task line we received from the server
                print("--- End of List ---\n")
            
            elif command_base == 'QUIT':
                # Read the final 'OK' and then exit
                response = reader.readline().strip()
                print(f"Server: {response}")
                if response == 'OK':
                    print("Quitting.")
                    break # Exit the main 'while True' loop
            
            else:
                # For ADD, REMOVE, MARK, or any ERROR
                # These all send a single line response ("OK" or "ERROR...")
                response = reader.readline().strip()
                print(f"Server: {response}")

    except EOFError:
        print("\nClient shutting down (EOF detected).") # This catches when the user presses Ctrl+D (end-of-file) to quit
    except Exception as e:
        print(f"An error occurred: {e}") # A general catch-all for other runtime errors
    finally:
        # Clean up the connection
        print("Closing connection...")
        writer.close()
        reader.close()
        s.close()
  ```
  ### Error Handling

-   Comprehensive exception handling throughout the code
    
-   Graceful degradation when connection issues occur
    
-   Clear error messages for user feedback
    

## Usage Example
[if no image, please see my pdf upload](https://github.com/lukeyfuxsnaz8iygd3q-ctrl/photos/blob/358eb09546ebf0f0c32743f5f4603c66f347b124/usage_example.png)
